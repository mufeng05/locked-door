import math
import struct


key = """-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA9d/0tTYVPQJgfmzWyQRn
kuZMomm2+jKEi8mFiRIoRLzP/6daOAcZ7UipNcMTA+bii9BTqftTqZmLraHA9FR7
47ZnGnQE7KimRIj+q35fhVCXVS2hna2OYkpKvyMUg6fcXuBQ2tRWjT/0+0y0w1xR
BFUcgGz9RDJrtTQC/4Rf94In95ZcggQlJuSoBvFoPws+X/dH32Zliq4jOAf+Mw1f
3bIPNme7bE3n475JmX2OtLll3tOHyHWcKtjdCgYgXqfWPesyn4FrB13bHJ45TiIg
6TOyTQdS0lHb6/6n+Cn2ofwOsJx07odgRgFdaS3lfSfGK3UKueVg/uSvOes1kWDP
RQIDAQAB
-----END PUBLIC KEY-----"""
key_hex = key.encode('utf-8').hex()
key_hex = [hex(int(key_hex[i:i+2], 16)) for i in range(0, len(key_hex), 2)]
print(key_hex)
reconstructed_floats = [math.sin((int(key_hex[i], 16) - 256 if int(key_hex[i], 16) >= 128 else int(key_hex[i], 16)) / 256.0) for i in range(len(key_hex))]
print(reconstructed_floats)

def format_output_with_newlines_float(hex_list, items_per_line=5):
    rounded_values = [f"{value:.6f}" for value in hex_list]
    formatted_lines = []
    for i in range(0, len(rounded_values), items_per_line):
        line = ", ".join(f"{value}f" for value in rounded_values[i:i+items_per_line])
        formatted_lines.append(line)
    return ",\n".join(formatted_lines)

formatted_output = format_output_with_newlines_float(reconstructed_floats)
# 以逗号分隔的形式输出
print(formatted_output)

reconstructed_hex_data = ''.join([struct.pack('<f', f).hex() for f in reconstructed_floats]).upper()
print(reconstructed_hex_data)


# raw_data = """1013333E1013333E1013333E1013333E1013333EE68A823ECE55883EC22F8C3E8607903EF598993E7755FF3D95689D3EC1E4A63EE68A823EEEC6953E8607903EB879843E7755FF3D09DD933ECE55883E9A6FAE3E1013333E1013333E1013333E1013333E1013333E96F51F3D3DB0973E8607903E8607903EE68A823E8607903E70FECD3E919B803EF598993EE68A823EA77CC83EC4D2CF3E72BBDA3E5F53CA3EC4D2CF3E4E29CC3EC22F8C3EEC1E623E5E85E53E81E03E3EE68A823E919B803E7A4F9F3ECE55883E0D438A3E919B803E919B803E12819B3EB879843E919B803E7A4F9F3EC2375E3E919B803E3DB0973E8607903E8607903EE68A823EB879843EA77CC83E09DD933EB879843E919B803E7A4F9F3ECE55883E919B803E3DF0E13EC4D2CF3E974EE73ED1F3C23EFC78D33E12819B3E97924E3EBF35A13ED1F3C23ED1F3C23EE51BD73E91F2913E5F53CA3EE68A823ED1F3C23E12819B3E12819B3ED1F3C23E0D438A3E703FBF3E96F51F3DFC78D33ED966563EFC78D33EC1E4A63EE916E93E9457DE3E52DEEA3E9457DE3E72BBDA3EB879843E641BA33E6500A53E217D523E5F53CA3EBF35A13E19BB463E83ABAA3E217D523E97924E3E19BB463EEEC6953E81E03E3E15F23A3EB879843E72BBDA3E52DEEA3E2FCE423E9A6FAE3E95689D3EBF35A13E91F2913E76C8A83E5924E03E5F53CA3EDDCCC43E9A6FAE3E70FECD3ECE55883EEC1E623E3DB0973E703FBF3E70FECD3E91F2913E9A6FAE3E9A6FAE3EF289DC3EF598993E9457DE3EF289DC3EE68A823E3FBBE33EC2375E3E12819B3E7A4F9F3E5924E03E91F2913EDDCCC43E703FBF3E15F23A3E703FBF3E641BA33E52DEEA3E83ABAA3EEB1B8E3E96F51F3D49A6D13EC4D2CF3E91F2913E217D523E974EE73EEB1B8E3E7A4F9F3E5924E03EC22F8C3E217D523E011AC13E83ABAA3E3DA74A3E3DA74A3E15F23A3E2064BD3E9A6FAE3EBB4F5A3E217D523EB879843ED966563E2FCE423E011AC13EB879843E91F2913E76C8A83E974EE73EBB4F5A3E95689D3E8607903E5924E03E12819B3E97924E3EC2375E3E2FCE423E76C8A83EFC78D33E15F23A3E2FCE423EEEC6953E5924E03ED966563E919B803E83ABAA3EEEC6953E2FCE423E12819B3E217D523E8607903EE58DAC3EE51BD73EE68A823E9A6FAE3E81E03E3E5F53CA3E5F53CA3E12819B3E15F23A3EA77CC83E52DEEA3E3DB0973E974EE73E76C8A83EE68A823E96F51F3D641BA33EEEC6953E7A4F9F3EE916E93E49A6D13E2064BD3E9A6FAE3E52DEEA3E5E85E53E91F2913ED966563E5E85E53E2064BD3E703FBF3EDDCCC43EF289DC3EDDCCC43E25A5C63EEC1E623E919B803E15F23A3EBB4F5A3E15F23A3E91F2913E49A6D13EE916E93E09DD933E19BB463ED1F3C23E3FBBE33E4E29CC3E011AC13E974EE73E52DEEA3E703FBF3E4E29CC3ED966563E3DB0973EE58DAC3E8607903EE916E93ECE55883E2064BD3E919B803E81E03E3E5F53CA3EF289DC3EEEC6953EF289DC3EB879843EBB4F5A3E0668863E83ABAA3E7A4F9F3ED966563E5F53CA3E3FBBE33EEEC6953E91F2913E18ECD83EFC78D33E8607903E011AC13E3E312B3E96F51F3D83ABAA3E5E85E53E8607903E25A5C63E9A6FAE3EDB4AD53ED966563E76C8A83EBF35A13E97924E3EE51BD73E011AC13EE51BD73E18ECD83E9A6FAE3E3DA74A3E217D523EA150B03EC4D2CF3EC2375E3EE58DAC3E8607903EC4D2CF3EA150B03EB879843E12819B3E6500A53E72BBDA3E7A4F9F3EC2375E3E9457DE3E4E29CC3E9457DE3E5924E03ECE55883E641BA33E5E85E53ED966563E70FECD3E52DEEA3E09DD933E3DF0E13E5E85E53E18ECD83E3DB0973ED1F3C23E25A5C63E6500A53EDDCCC43E18ECD83EC22F8C3E8607903EEEC6953ED966563E3E312B3E9A6FAE3EA77CC83EC22F8C3E217D523E9A6FAE3E25A5C63E9457DE3EE58DAC3E703FBF3E96F51F3D2FCE423EBB4F5A3E011AC13EB879843E9A6FAE3E18ECD83EC2375E3E5E85E53E91F2913E641BA33E703FBF3EE916E93E12819B3E3E312B3E81E03E3E3DB0973E703FBF3E6500A53E76C8A83EE916E93E72BBDA3E97924E3E6500A53EE68A823EE916E93EB879843E5F53CA3E0D438A3E0D438A3E3FBBE33E72BBDA3E3DB0973E3DB0973EE916E93EEB1B8E3EA77CC83E12819B3EBB4F5A3EEB1B8E3E974EE73E83ABAA3EE58DAC3E70FECD3E09DD933E95689D3E3DB0973EE916E93E91F2913E70FECD3E97924E3E81E03E3E2064BD3E97924E3ECE55883E8607903E8607903E5E85E53E19BB463E3E312B3E9A6FAE3E9457DE3E919B803E76C8A83EA150B03E96F51F3D2064BD3E5E85E53E8607903E0668863E919B803E7A4F9F3E919B803EE68A823E96F51F3D1013333E1013333E1013333E1013333E1013333ECE55883EF598993E0668863E7755FF3D95689D3EC1E4A63EE68A823EEEC6953E8607903EB879843E7755FF3D09DD933ECE55883E9A6FAE3E1013333E1013333E1013333E1013333E1013333E"""
floats = [struct.unpack('<f', bytes.fromhex(reconstructed_hex_data[i:i+8]))[0] for i in range(0, len(reconstructed_hex_data), 8)]
v3 = [0] * len(floats)
for i in range(len(floats)):
    v3[i] = round(math.asin(floats[i]) * 256.0)
    if v3[i] < 0:
        v3[i] = 256 + v3[i]
v3_hex = [hex(x) for x in v3]
v3_hex_str = ''.join(chr(int(x, 16)) for x in v3_hex)
print(v3_hex_str)

def hex_to_little_endian(hex_str):
    # 检查输入是否为有效的十六进制字符串
    if not all(c in '0123456789ABCDEFabcdef' for c in hex_str):
        raise ValueError("Invalid hexadecimal string")
    
    # 确保字符串长度为8的倍数，不足则补零
    if len(hex_str) % 8 != 0:
        hex_str = hex_str.ljust((len(hex_str) // 8 + 1) * 8, '0')
    
    # 分割字符串为每8个字符一组
    chunks = [hex_str[i:i+8] for i in range(0, len(hex_str), 8)]
    
    # 转换每个组为小端序
    little_endian_chunks = []
    for chunk in chunks:
        # 确保每个组有8个字符
        chunk = chunk.ljust(8, '0')
        # 反转字节顺序
        little_endian = ''.join(reversed([chunk[i:i+2] for i in range(0, 8, 2)]))
        # 转换为带0x前缀的格式
        little_endian_chunks.append(f"0x{little_endian}")
    
    return little_endian_chunks

def format_output_with_newlines(hex_list, items_per_line=5):
    formatted_lines = []
    for i in range(0, len(hex_list), items_per_line):
        line = ", ".join(hex_list[i:i+items_per_line])
        formatted_lines.append(line)
    return ",\n".join(formatted_lines)

try:
    result = hex_to_little_endian(reconstructed_hex_data)
    formatted_output = format_output_with_newlines(result)
    # 以逗号分隔的形式输出
    print(formatted_output)
except ValueError as e:
    print(f"Error: {e}")